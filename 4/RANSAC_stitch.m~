function [best_paramA, best_paramb, best_inlier_matrix, success_rates] = RANSAC_stitch(Ia,Ib,P,N)


[matched_a,matched_b] = keypoint_matching(Ia,Ib);

n_matches = size(matched_a,2);

% initialize matrix that stores the best inliers in columns as emtpy matrix
% -> (2, #best inliers) = size(inlier_matrix)
% it saves the coordinates of transformed points of image2
% that now lie in image1
best_inlier_matrix = [];
best_n_inliers= 0;
best_paramA= [];
best_paramb= [];

success_rates = []; %success rate after each iteration

for k = 1:N
    perm = randperm(n_matches) ;
    current_best_inlier_matrix = [];
    
    x_diff = round(sum((w_left - matched_a(1, perm(1:P)) + matched_b(1, perm(1:P)))) / P)
    y_diff = round(sum((matched_a(2, perm(1:P)) - matched_b(2, perm(1:P)))) / P)

    n_inliers=0;
    diff_matrix = zeros(size(matches, 2), 2);
    diff_matrix(:, 1) = matched_a(2, :) - matched_b(2, :) - y_diff;
    diff_matrix(:, 2) = w_left - matched_a(1, :) + matched_b(1, :) - x_diff
    diff_vector = vecnorm(diff_matrix') < 10;
    sum(diff_vector)
    % divide into A-parameter and b-parameter for better overview
    for j = 1:n_matches
        x1 = matched_a(1,j);
        y1 = matched_a(2,j);
        x2 = matched_b(1,j);
        y2 = matched_b(2,j);
        % transform all the points and see, which ones lie in a radius of
        % 10 pixels. These are then called 'inliers'
        deviation = paramA*[x1;y1] + paramb - [x2;y2];
        if norm(deviation)<=10
            n_inliers=n_inliers+1;
            current_best_inlier_matrix = [current_best_inlier_matrix.'; paramA*[x1;y1] + paramb].';
        end
    end
    
    % Now if we have more inliers (aka better transformation approximation)
    % then before, we save all the data
    if n_inliers>best_n_inliers 
        best_n_inliers=n_inliers;
        best_paramA=paramA;
        best_paramb=paramb;
        best_inlier_matrix = current_best_inlier_matrix;
    end
    
    success_rates(k) = best_n_inliers/n_matches;
end